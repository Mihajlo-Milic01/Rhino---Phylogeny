moves.append( mvScale(speciation_rate, lambda=1.0,  weight=1) )
moves.append( mvScale(extinction_rate, lambda=0.01, weight=1) )
moves.append( mvScale(extinction_rate, lambda=0.1,  weight=1) )
moves.append( mvScale(extinction_rate, lambda=1,    weight=1) )
diversification := speciation_rate - extinction_rate
turnover := extinction_rate/speciation_rate
rho <- 1.0 #probability of sampling extant taxa (all living rhino species are present in the character matix)
psi ~ dnExponential(10) # fosill recovery (sampling) rate 
moves.append( mvScale(psi, lambda=0.01, weight=1) )
moves.append( mvScale(psi, lambda=0.1,  weight=1) )
moves.append( mvScale(psi, lambda=1,    weight=1) )
origin_time ~ dnUnif(55.0, 64.0) # Divergence of Rhinocerotoidea and lineage leading to modern Tapiridae; based on Liu et al 2021 and Bai et al 2020
moves.append( mvSlide(origin_time, delta=0.01, weight=5.0) )
moves.append( mvSlide(origin_time, delta=0.1,  weight=5.0) )
moves.append( mvSlide(origin_time, delta=1,    weight=5.0) )
fbd_dist = dnFBDP(originAge=origin_time, lambda=speciation_rate, mu=extinction_rate, psi=psi, rho=rho, taxa=taxa)
## might use the different function for our FBD model
moves.append( mvFNPR(fbd_dist, weight=15.0) )
for (i in 1:n_data_subsets) {
    er_prior[i] <- v(1,1,1,1,1,1)
    er[i] ~ dnDirichlet(er_prior[i])
    moves.append( mvBetaSimplex(er[i], alpha=10, tune=true, weight=5.0) )
}
# stationary frequencies
for (i in 1:n_data_subsets) {
    pi_prior[i] <- v(1,1,1,1)
    pi[i] ~ dnDirichlet(pi_prior[i])
    moves.append( mvBetaSimplex(pi[i], alpha=10, tune=true, weight=5.0) )
}
# GTR model matrix
for (i in 1:n_data_subsets) {
    Q_dna[i] := fnGTR(er[i],pi[i]) 
}
## +G +I
for (i in 1:n_data_subsets) {
    alpha[i] ~ dnExponential( 1.0 )
    gamma_rates[i] := fnDiscretizeGamma( alpha[i], alpha[i], 4)
    moves.append( mvScale(alpha[i], lambda=0.01, weight=1.0) )
    moves.append( mvScale(alpha[i], lambda=0.1,  weight=1.0) )
    moves.append( mvScale(alpha[i], lambda=1,    weight=1.0) )
}
for (i in 1:n_data_subsets) {
    pinvar[i] ~ dnBeta(1,1)
    moves.append( mvBetaProbability(pinvar[i], delta=10.0, tune=true, weight=1.0) )
}
for (i in 1:n_data_subsets) {
    seq[i] ~ dnPhyloCTMC(tree=fbd_tree, Q=Q_dna[i], branchRates=branch_rates[i], siteRates=gamma_rates[i], pInv=pinvar[i], type="DNA")
    seq[i].clamp(dna_data[i])
}model of character evolution for morphological data
num_cats = 4
#beta_scale ~ dnUniform( 0.0, 1E4 )
beta_scale ~ dnLognormal( 0.0, sd=2*0.587405 )
beta_scale.setValue( 1.0 )
cats := fnDiscretizeBeta(beta_scale, beta_scale, num_cats)
for (i in 1:cats.size()) {
    Q_morpho[i] := fnF81(simplex(abs(1-cats[i]), cats[i]))
}
matrix_probs <- simplex( rep(1,num_cats) )
alpha_morpho ~ dnExponential( 1.0 )
rates_morpho := fnDiscretizeGamma( alpha_morpho, alpha_morpho, 4 )
moves.append( mvScale(alpha_morpho, lambda=0.01, weight=5.0) )
moves.append( mvScale(alpha_morpho, lambda=0.1,  weight=3.0) )
moves.append( mvScale(alpha_morpho, lambda=1,    weight=1.0) )
clock_morpho ~ dnExponential(1.0)
moves.append( mvScale(clock_morpho, lambda=0.01, weight=4.0) )
moves.append( mvScale(clock_morpho, lambda=0.1,  weight=4.0) )
moves.append( mvScale(clock_morpho, lambda=1,    weight=4.0) )
phyMorpho ~ dnPhyloCTMC(tree=fbd_tree, siteRates=rates_morpho, branchRates=clock_morpho, Q=Q_morpho, type="Standard", coding="variable", siteMatrices=matrix_probs)
phyMorpho.clamp(morpho)
branch_rates_mean ~ dnExponential(rep(10.0, n_data_subsets))
moves.append( mvScale(branch_rates_mean, lambda=0.01, weight=1.0) )
moves.append( mvScale(branch_rates_mean, lambda=0.1,  weight=1.0) )
moves.append( mvScale(branch_rates_mean, lambda=1.0,  weight=1.0) )
n_branches <- 2 * n_taxa - 2 # for rooted tree
for(i in 1:n_branches){
    branch_rates[i] ~ dnExp(1/branch_rates_mean)
    moves.append( mvScale(branch_rates[i], lambda=1.0,  weight=1.0) )
    moves.append( mvScale(branch_rates[i], lambda=0.1,  weight=1.0) )
    moves.append( mvScale(branch_rates[i], lambda=0.01, weight=1.0) )
}
moves.append( mvVectorScale(branch_rates, lambda=0.01, weight=4.0) )
moves.append( mvVectorScale(branch_rates, lambda=0.1,  weight=4.0) )
moves.append( mvVectorScale(branch_rates, lambda=1.0,  weight=4.0) )
branch_rates_mean ~ dnExponential(rep(10.0, n_data_subsets))
moves.append( mvScale(branch_rates_mean, lambda=0.01, weight=1.0) )
moves.append( mvScale(branch_rates_mean, lambda=0.1,  weight=1.0) )
moves.append( mvScale(branch_rates_mean, lambda=1.0,  weight=1.0) )
branch_rates_mean ~ dnExponential(10.0, n_data_subsets)
moves.append( mvScale(branch_rates_mean, lambda=0.01, weight=1.0) )
moves.append( mvScale(branch_rates_mean, lambda=0.1,  weight=1.0) )
moves.append( mvScale(branch_rates_mean, lambda=1.0,  weight=1.0) )
n_branches <- 2 * n_taxa - 2 # for rooted tree
for(i in 1:n_branches){
    branch_rates[i] ~ dnExp(1/branch_rates_mean)
    moves.append( mvScale(branch_rates[i], lambda=1.0,  weight=1.0) )
    moves.append( mvScale(branch_rates[i], lambda=0.1,  weight=1.0) )
    moves.append( mvScale(branch_rates[i], lambda=0.01, weight=1.0) )
}
moves.append( mvVectorScale(branch_rates, lambda=0.01, weight=4.0) )
moves.append( mvVectorScale(branch_rates, lambda=0.1,  weight=4.0) )
